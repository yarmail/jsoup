<!doctype html>
<html lang="ru" dir="auto">
 <body id="top">
  <main class="main">
   <article class="post-single">
    <img loading="lazy" sizes="(min-width: 768px) 720px, 100vw" src="./images/Kerberos_logo.jpg" alt width="1080" height="1080">
    <div></div>
    <div>
     <h2 id="вступление">Вступление</h2>
     <p>На мой взгляд специалисту по тестированию на проникновение инфраструктуры на базе Active Directory важно понимать общее устройство протокола Kerberos. Вот лишь несколько причин почему:</p>
     <ul>
      <li>Знание устройства протокола Kerberos необходимо для понимания ряда классических атак.</li>
      <li>Периодически появляются новые атаки, но прежде чем приступать к их эксплуатации, необходимо разобраться к каким последствиям они могут привести. Без знания Kerberos это порой затруднительно, либо вовсе невозможно.</li>
      <li>Личная чуйка, что если человек называет себя специалистом, то он должен обладать несколько более глубокими знаниями, чем название инструмента или кнопки, на которую надо нажать.</li>
     </ul>
     <p>Про Kerberos и атаки на него уже написано немало статей. Многие из указанных статей предназначены либо для математиков, либо для сетевых инженеров, либо для специалистов по тестированию на проникновение. Материал часто преподносится однобоко в разрозненной форме и приходится тратить много времени для отбора действительно полезных работ и их склейки на полях личных заметок.</p>
     <p>В этом цикле статей буду пытаться разобрать, как в теории устроен протокол Kerberos и какие атаки с его использованием можно осуществить на практике в Active Directory. Также будут приведены некоторые рекомендации по противодействию рассматриваемым атакам.</p>
     <p>В первой части будет рассмотрено устройство Kerberos в общем случае, а также реализация Kerberos в Active Directory.</p>
     <blockquote>
      <p>К материалу не стоит относится как к истине в последней инстанции. Только дураки не сомневаются.</p>
     </blockquote>
     <h2 id="экскурс-краткий-и-исторический">Экскурс. Краткий и исторический</h2>
     <p>Протокол Kerberos был разработан в MIT, как часть научно-исследовательского проекта Афина, предназначенного для создания распределенной образовательной среды. К 1988 году проект достиг поставленных целей. В частности, было опубликовано описание протокола Kerberos v4, являющегося основой системы единого входа в разработанную среду. Предыдущие версии 1-3 были ранними прототипами и не использовались за пределами MIT.</p>
     <p>В 1989 году состоялся официальный релиз Kerberos v4.</p>
     <p>Однако протоколу было куда развиваться. Например, можно выделить следующие недостатки Kerberos v4:</p>
     <ul>
      <li>Использование слабых криптографических алгоритмов.</li>
      <li>Уязвимости в архитектуре протокола, позволяющие проводить ряд атак методом оффлайн-перебора в отношение паролей пользователей.</li>
      <li>Отсутствие возможности делегирования учетных данных или использования дополнительных факторов аутентификации.</li>
     </ul>
     <p>C целью устранения приведенных недостатков в 1993 году вышел новый протокол Kerberos v5.</p>
     <p>В 1999 году Microsoft объявила о поддержке Kerberos v5 в своей будущей операционной системе Windows 2000, что было впоследствии реализовано в качестве соответствующего компонента Active Directory. До этого для аутентификации в рабочих группах на базе операционной системы Windows использовался протокол NT LAN Manager (NTLM), одна из версий которого (NTLM v2) применяется для локальной аутентификации в современных системах до сих пор. Подробное рассмотрение протокола NTLM v2 выходит за рамки статьи. Важно отметить, что указанный протокол также обладает рядом недостатков, которые было решено избежать при внедрении Kerberos v5 в Windows 2000.</p>
     <p>В настоящее время Kerberos v5 можно считать довольно возрастным протоколом, тем не менее он используется во множестве различных систем, а не только в Active Directory. Вот неполный перечень:</p>
     <ul>
      <li>Amazon Web Services</li>
      <li>Apple macOS</li>
      <li>Google Cloud</li>
      <li>Microsoft Azure</li>
      <li>Oracle Solaris</li>
      <li>Red Hat Linux</li>
     </ul>
     <blockquote>
      <p>Всюду далее речь будет идти именно о Kerberos v5. Для читаемости Kerberos v5 будет называться просто Kerberos.</p>
     </blockquote>
     <h2 id="требования-к-протоколу-kerberos">Требования к протоколу Kerberos</h2>
     <p>Разобраться с принципом работы протокола Kerberos поначалу не просто. Постоянно приходится перечитывать ранее изученный материал и держать в голове множество деталей. Периодически возникает вопрос: почему все так сложно устроено?</p>
     <p>Чтобы корректно ответить на заданный вопрос и, что не менее важно, понять ответ, требуется обладать познаниями в устройстве криптографических протоколов, а также смежных дисциплинах. Полагаю, что копать настолько глубоко смысла нет. Все же чтобы понимать, чем обусловлены навороты Kerberos приведу ряд требований, которым протокол должен был отвечать:</p>
     <ul>
      <li>
       <p>Подразумевается, что обмен сообщений осуществляется с доверенных устройств, но в открытой недоверенной среде. Сетевой трафик может быть прослушан злоумышленником, а передаваемые сообщения могут быть подменены или перенаправлены. Таким образом секреты участников протокола ни при каких условиях не должны передаваться по сети в открытом виде.</p>
       <blockquote>
        <p>Любопытный факт: Kerberos разрабатывался до появления SSL.</p>
       </blockquote></li>
      <li>
       <p>Информация о пользователях и их секретах должна хранится в выделенном месте. Это ограничение обусловлено следующими соображениями:</p>
       <ul>
        <li>Необходимо минимизировать количество критических объектов, которые требуется защищать.</li>
        <li>Добавление нового, удаление старого, изменение текущего секрета у клиента или сервиса не должно требовать уведомления всех остальных участников протокола. Думаю, полезной будет следующая иллюстрация:</li>
       </ul></li>
     </ul>
     <p></p><img src="./images/Topology.png" alt="topology">
     <p></p>
     <ul>
      <li>Должна поддерживаться технология единого входа (Single Sign-On). Это ограничение обусловлено тем, что пользователю неудобно каждый раз при обращении к ресурсу заново вводить пароль.</li>
      <li>Успешное окончание работы протокола должно означать успешную взаимную аутентификацию сторон.</li>
      <li>В результате работы протокола между клиентом и сервисом должен быть сформирован секретный сессионный ключ. Знание сессионного ключа позволяет злоумышленнику расшифровать некоторые старые сообщения, но организовать новую сессию с использованием уже известного сессионного ключа не получится.</li>
     </ul>
     <h2 id="список-терминов">Список терминов</h2>
     <p>Прежде чем приступить к технической части определимся с терминологией, чтобы в дальнейшем избежать путаницы.</p>
     <p><strong>Kerberos</strong> – в первую очередь протокол аутентификации, но при этом предусматривающий возможность транспортировки информации необходимой для авторизации.</p>
     <p>Важно не путать:</p>
     <blockquote>
      <p><strong>Аутентификация</strong> – процесс проверки подлинности. То есть проверка того, что пользователь, пытающийся получить доступ к системе именно тот, за кого себя выдает.<br><strong>Авторизация</strong> – процесс проверки прав доступа. Авторизация может быть применена только к аутентифицированному пользователю, так как перед тем, как проверять права доступа, необходимо выяснить личность объекта, которому указанные права планируется предоставить.</p>
     </blockquote>
     <p><strong>Сервер</strong> – сетевой объект, обеспечивающий функционирование одного или нескольких сервисов. Примеры серверов: файловый сервер, почтовый сервер.</p>
     <p><strong>Клиент</strong> – объект, обращающийся к сервису с целью получения доступа к ресурсам. Примеры клиентов: учетная запись или рабочая станция пользователя.</p>
     <p><strong>Область действия</strong> (<em>Realm</em>) – совокупность клиентов, серверов и сервисов, участвующих в протоколе Kerberos.</p>
     <p><strong>Принципал</strong> (<em>Principal</em>) – это строка, полностью идентифицирующая участника протокола Kerberos.</p>
     <p>Принципал может быть именем сервиса (<em>Service Principal Name</em>), или именем клиента (<em>User Principal Name</em>). Форматы принципалов для клиентов и сервисов различаются.</p>
     <p>Принципал клиента имеет следующую форму: <em>principal-name[/instance-name]@REALM</em> Пример: имя пользователя - <em>Ivan</em>, а область действия - <em>DOMAIN.LOCAL</em>, то полный принципал будет <em>Ivan@DOMAIN.LOCAL</em>.</p>
     <p>Расширение <em>instance-name</em> является опциональным и позволяет любому пользователю иметь более одного принципала. Так, если <em>Ivan</em> является администратором области <em>DOMAIN.LOCAL</em>, имя принципала будет <em>Ivan/admin@DOMAIN.LOCAL</em>, и у этого принципала будут другие права (и удостоверяющие данные).</p>
     <p><a href="https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spn-setspn-syntax.aspx">Принципал сервиса</a> имеет следующую форму: <em>service-name/host[:port]@REALM</em>, где</p>
     <ul>
      <li><em>service-name</em> – это специфичная для приложения строка, идентифицирующая сервис на этом хосте.</li>
      <li><em>host</em> – это доменное имя хоста, на котором работает сервис</li>
      <li><em>port</em> - порт на котором запущена служба.</li>
     </ul>
     <p>Пример: для сервиса <em>ftp</em>, работающего на хосте с именем <em>fileserver.example.com</em> в области <em>@EXAMPLE.COM</em>, имя принципала сервиса будет <em>ftp/fileserver.example.com@EXAMPLE.COM</em>.</p>
     <p>Почему такое внимание уделяется этим именам? В дальнейшем будет понятнее, но уже сейчас можно отметить, что в Kerberos для идентификации сервера требуется именно принципал (имя), тогда как в NTLM может использоваться IP-адрес.</p>
     <blockquote>
      <p>Примечание: возможность использования IP-адресов была <a href="https://learn.microsoft.com/en-us/windows-server/security/kerberos/configuring-kerberos-over-ip">добавлена</a> в новых клиентах Windows.</p>
     </blockquote>
     <p>Рассмотрим пример: есть рабочая станция (DNS-имя: <em>station.domain.local</em>, IP-адрес: 192.168.10.12) с общедоступной сетевой папкой <em>scan</em>. При открытии проводника и переходу по UNC-пути <em>\\station.domain.local\scan</em> будет использоваться Kerberos, но при указании UNC-пути <em>\\192.168.10.12\scan</em> будет использоваться NTLM, так как принципал отсутствует. В частности, поэтому администраторы не любят отключать NTLM, так как устаревшее сетевое оборудование (принтеры, роутеры и пр.) может быть настроено со статическими IP-адресами или вовсе не поддерживать Kerberos.</p>
     <p><strong>Центр распределения ключей</strong> (<em>Key Distribution Center</em>, далее – KDC) является доверенным центром аутентификации для всех участников протокола Kerberos в рамках определенной области действия.</p>
     <p>KDC включает в себя следующие компоненты:</p>
     <ul>
      <li><strong>База данных Kerberos</strong>, предназначенная для хранения информации о всех принципалах и их секретах.</li>
      <li><strong>Сервер аутентификации</strong> (<em>Authentication Server, AS</em>), обрабатывающий запросы на аутентификацию клиентов к области действия протокола Kerberos;</li>
      <li><strong>Сервер выдачи разрешений</strong> (<em>Ticket Granting Server, TGS</em>), обрабатывающий запросы на аутентификацию к определенному сервису, функционирующего в составе указанной области действия.</li>
     </ul>
     <p>Проиллюстрируем вышесказанное следующей зарисовкой:</p>
     <p></p><img src="./images/realm_high.png" alt="realm_members">
     <p></p>
     <h2 id="аутентификация-с-использованием-kerberos">Аутентификация с использованием Kerberos</h2>
     <p></p><img src="./images/matreshki.png" alt="matreshki">
     <p></p>
     <p>Начнем от общего и перейдем к частному.</p>
     <h3 id="житейская-аналогия">Житейская аналогия</h3>
     <p>Рассмотрим немного выдуманную, но полезную для последующих аналогий ситуацию. Представим парк развлечений. Допустим, что перечень разрешенных посетителей парка содержится в специальной базе данных. Для тех, кто в базе отсутствует проход воспрещен. Как организовано посещение парка:</p>
     <ol>
      <li>Посетитель приходит на вход и показывает охраннику свой паспорт.</li>
      <li>Охранник проверяет наличие посетителя в базе данных.</li>
      <li>Охранник выдает посетителю суточный билет на посещение парка.</li>
      <li>Посетитель выбирает понравившийся ему аттракцион и идет на кассу, чтобы получить билет.</li>
      <li>На кассе проверяют суточный билет посетителя и выдают билет на аттракцион.</li>
      <li>Посетитель идет на выбранный аттракцион и показывает смотрителю аттракциона, полученный на кассе билет.</li>
      <li>Смотритель проверяет билет и пропускает посетителя.</li>
      <li>Посетитель при желании может посмотреть бейджик смотрителя, чтобы убедиться, что он действительно сотрудник парка.</li>
     </ol>
     <p>Если посетитель захотел пойти на другой аттракцион, он снова идет на кассу и показывает суточный билет. Далее повторяется процесс из шагов 5, 6, 7 только с другим смотрителем и другим аттракционом.</p>
     <h3 id="по-верхам-в-общем-виде">По верхам в общем виде</h3>
     <p>Теперь по аналогии рассмотрим упрощенную схему аутентификации с использованием Kerberos:</p>
     <p></p><img src="./images/Kerberos_general_scheme_design.png" alt="scheme">
     <p></p>
     <ol>
      <li>Клиент отправляет запрос на аутентификацию к области действия.</li>
      <li>Сервер аутентификации проверяет подлинность Клиента с использованием Базы данных Kerberos.</li>
      <li>Сервер выдает Клиенту разрешение (пока просто назовем его TGT) на получение отдельных разрешений (далее – ST), требующимся для доступа к сервисам, входящим в область действия.</li>
      <li>С использованием полученного на шаге №3 разрешения (TGT) Клиент запрашивает разрешение на доступ к Сервису А («ST для А»).</li>
      <li>Сервер выдачи разрешений проверяет TGT и выдает Клиенту ST для доступа к сервису А.</li>
      <li>Клиент с использованием «ST для А» запрашивает у Сервиса А доступ к его ресурсам.</li>
      <li>Сервис А проверяет «ST для А» и предоставляет Клиенту доступ к своим ресурсам. При необходимости сервис также проходит аутентификацию перед клиентом.</li>
     </ol>
     <p>В дальнейшем при необходимости доступа к другому сервису:</p>
     <ol start="8">
      <li>С использованием полученного на шаге №3 разрешения (TGT) Клиент запрашивает разрешение на доступ к Сервису Б («ST для Б»).</li>
      <li>Сервер выдачи разрешений проверяет TGT и выдает Клиенту ST для доступа к сервису Б.</li>
      <li>Клиент с использованием «ST для Б» запрашивает у Сервиса Б доступ к его ресурсам.</li>
      <li>Сервис Б проверяет «ST для Б» и предоставляет Клиенту доступ к своим ресурсам.</li>
     </ol>
     <p>Видно, что стороны обмениваются сообщениями, содержащими запросы и ответы с разрешениями. Официально форматы указанных сообщений задокументированы в RFC 4120.</p>
     <p>Теперь переназовем передаваемые сообщения в соответствие с RFC:</p>
     <ul>
      <li>Запрос на аутентификацию к области действия (шаг 1) - сообщение <em>KRB_AS_REQ</em>.</li>
      <li>Ответ сервера на запрос аутентификации клиента (шаг 3) – сообщение <em>KRB_AS_REP</em>.</li>
      <li>Разрешение на получение разрешений – <em>TGT</em> (<em>Ticket Granting Ticket</em>).</li>
     </ul>
     <p>Другие встречающиеся в литературе названия: мандат / билет на получение разрешений, первичное удостоверение пользователя.</p>
     <blockquote>
      <p>Примечание: в различных источниках часто встречается словосочетание «TGT билет», но в аббревиатуре TGT уже заложено слово «билет» - Ticket Granting Ticket, поэтому правильнее говорить просто «TGT».</p>
     </blockquote>
     <ul>
      <li>
       <p>Запрос на доступ к сервису (шаг 4) – сообщение <em>KRB_TGS_REQ</em>.</p></li>
      <li>
       <p>Ответ сервера выдачи разрешений (шаг 5) – сообщение <em>KRB_TGS_REP</em>.</p></li>
      <li>
       <p>Разрешение на доступ к сервису – <em>ST</em> (<em>Service Ticket</em>) Другие встречающиеся названия: TGS билет, билет сервиса, мандат сервиса.</p></li>
      <li>
       <p>Запрос клиента на аутентификацию к сервису (шаг 6) – сообщение <em>KRB_AP_REQ</em>.</p></li>
      <li>
       <p>Опциональный ответ с аутентификацией сервиса перед клиентом (шаг 7) – сообщение <em>KRB_AP_REP</em>.</p></li>
     </ul>
     <p>Чтобы проще было запомнить:</p>
     <ul>
      <li>KRB ~ <strong>K</strong>e<strong>RB</strong>eros</li>
      <li>AS ~ <strong>A</strong>uthentication <strong>S</strong>erver</li>
      <li>REP ~ <strong>RE</strong>s<strong>P</strong>onse</li>
      <li>REQ ~ <strong>REQ</strong>uest</li>
      <li>AP ~ <strong>AP</strong>plication server</li>
     </ul>
     <p>Далее каждый запрос будет разобран подробнее.</p>
     <h2 id="разбор-аутентификации-в-kerberos-согласно-rfc">Разбор аутентификации в Kerberos согласно RFC</h2>
     <p>В начале имеются три участника протокола Kerberos:</p>
     <ol>
      <li>Клиент</li>
      <li>Сервис</li>
      <li>Центр распределения ключей</li>
     </ol>
     <p>Каждый из участников обладает своим долговременным секретом (ключом). Кроме того, центр распределения ключей обладает секретами всех участников.</p>
     <p></p><img src="./images/gen_secrets.png" alt="secrets_distribution">
     <p></p>
     <h3 id="алгоритм-формирования-ключа">Алгоритм формирования ключа</h3>
     <p>Ключ формируется как результат работы хэш-функции под названием string2key. Хэш может вычисляться разными способами в зависимости от соответствующих настроек Kerberos, в частности поддерживаются следующие алгоритмы:</p>
     <table>
      <thead>
       <tr>
        <th>Название алгоритма (etype)</th>
        <th>Способ вычисления ключа</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>RC4_HMAC_MD5</td>
        <td>NT-хэш пароля участника</td>
       </tr>
       <tr>
        <td>AES128_CTS_HMAC_SHA1_96</td>
        <td>PBKDF2(пароль, соль*, kvno**, 128)</td>
       </tr>
       <tr>
        <td>AES256_CTS_HMAC_SHA1_96</td>
        <td>PBKDF2(пароль, соль*, kvno**, 256)</td>
       </tr>
      </tbody>
     </table>
     <p>В последних версиях Windows по умолчанию используется шифрование AES. Но для совместимости с системами ниже Windows Vista и Windows 2008 Server необходима поддержка алгоритма RC4.</p>
     <p>Соль формируется следующим образом:</p>
     <ul>
      <li>
       <p>Для доменных пользователей: полностью определенное имя домена заглавными буквами (FQDN) + регистр зависимое имя пользователя.</p>
       <blockquote>
        <p>Пример: <em>DOMAIN.LOCALuser</em></p>
       </blockquote></li>
      <li>
       <p>Для компьютеров: <em>FQDN + host + регистр зависимое имя компьютера без $ в конце</em>.</p>
       <blockquote>
        <p>Пример: <em>DOMAIN.LOCALhostcomputer.domain.local</em></p>
       </blockquote></li>
     </ul>
     <p><strong>kvno</strong> - key version number (в переводе - номер версии ключа). kvno представляет собой счетчик, увеличивающий значение каждый раз при смене пароля.</p>
     <p>Таким образом, у одного и того же пользователя в разных доменах или для разных учетных записей будут разные секреты (хэши паролей), даже если пароль одинаковый. То есть строить радужные таблицы для указанных хэшей нецелесообразно.</p>
     <p>Источники:</p>
     <ul>
      <li><a href="https://www.thehacker.recipes/ad/movement/kerberos">Kerberos from Hacker recipes</a></li>
      <li><a href="https://snovvcrash.rocks/2021/05/21/calculating-kerberos-keys.html">A Note on Calculating Kerberos Keys for AD Accounts</a> (snovvcrash)</li>
     </ul>
     <h3 id="krb_as_req">KRB_AS_REQ</h3>
     <p><img src="./images/KRB_AS_REQ_NO_PRE.png" alt="KRB_AS_REQ_NO_PRE"></p>
     <p>Клиент отправляет серверу аутентификации запрос, содержащий:</p>
     <ul>
      <li>Принципал клиента</li>
      <li>Срок жизни билета</li>
     </ul>
     <blockquote>
      <p>Примечание: если это не первый материал по Kerberos, который вы читаете и возникает вопрос, почему отсутствует предварительная аутентификации, то поясню – это дополнительная настройка протокола, которая в «классической» реализации по умолчанию отключена. В реализации Kerberos для Active Directory, указанная настройка напротив по умолчанию активна и этот случай будет рассмотрен чуть <a href="#krb_as_req-%D1%81-%D0%BF%D1%80%D0%B5%D0%B4%D0%B2%D0%B0%D1%80%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B5%D0%B9">позже</a>.</p>
     </blockquote>
     <h3 id="krb_as_rep">KRB_AS_REP</h3>
     <p><img src="./images/KRB_AS_REP_NO_PRE.png" alt="KRB_AS_REP"></p>
     <p>Сервер аутентификации по полученному принципалу находит в базе Kerberos секрет клиента. Кроме того, для дальнейшего общения с KDC сервер аутентификации случайным образом генерирует сессионный ключ. В итоге в ответ клиенту отправляются два сообщения.</p>
     <p>Первое сообщение зашифровано с использованием секрета клиента и содержит:</p>
     <ul>
      <li>Сессионный ключ для KDC</li>
      <li>Метка времени</li>
      <li>Срок жизни TGT</li>
     </ul>
     <p>Второе сообщение (TGT) зашифровано уже с использованием (!) секрета KDC и включает в себя те же самые данные, что и первое сообщение, но вместе с принципалом клиента.</p>
     <blockquote>
      <p>Примечание: время жизни TGT определяется, как наименьшее время среди запрошенного клиентом и хранящегося в настройках центра распределения ключей.</p>
     </blockquote>
     <p>Клиент, приняв ответ, может расшифровать только первое сообщение. Таким образом он получает сессионный ключ для дальнейшего общения с KDC. TGT также сохраняется у клиента в зашифрованном виде.</p>
     <h3 id="krb_tgs_req">KRB_TGS_REQ</h3>
     <p><img src="./images/TGS_REQ.png" alt="KRB_TGS_REQ"></p>
     <p>Теперь, пройдя аутентификацию, клиент желает получить доступ к какому-то сервису. Для этого он отправляет серверу выдачи разрешений запрос, содержащий:</p>
     <ul>
      <li>Принципал сервиса</li>
      <li>Аутентификатор, состоящий из принципала клиента и метки времени, зашифрованных с использованием извлеченного ранее сессионного ключа для общения с KDC.</li>
      <li>Сохраненный TGT</li>
     </ul>
     <p>Приняв запрос, сервер выдачи разрешений прежде всего выполняет проверку полученных данных. Сначала с использованием секрета KDC сервер расшифровывает TGT (1) и по метке времени со сроком действия убеждается, что TGT не протух (2).</p>
     <p>Далее сервер извлекает сессионный ключ для KDC. Несмотря на то, что указанный ключ был создан в KDC, нужды хранить его в базе Kerberos нет. Действительно, TGT не может быть изменен кем-либо кроме KDC, поэтому полученным из него данным можно доверять.</p>
     <p>Возникает важный вопрос - почему можно быть уверенным, что TGT не отправлен злоумышленником, перехватившим его при прослушивании сетевого трафика? Для этого в запросе прилагается аутентификатор. Аутентификатор зашифрован с использованием сессионного ключа KDC, который мог быть извлечен из KRB_AS_REP запроса только определенным клиентом. Метка времени добавляется с целью предотвращения атак методом повтора, чтобы злоумышленник не смог вставить в свой запрос старый аутентификатор клиента, перехваченный из прошлых сообщений.</p>
     <p>Сервер выдачи разрешений сравнивает принципалы пользователя из TGT и аутентификатора, а также убеждается, что аутентификатор был сформирован не более двух минут назад.</p>
     <h3 id="krb_tgs_rep">KRB_TGS_REP</h3>
     <p><img src="./images/TGS_REP.png" alt="KRB_TGS_REP"></p>
     <p>В случае успешного завершения проверок сервер выдачи разрешений отправляет клиенту ответ, содержащий два сообщения. Первое сообщение зашифровано с использованием сессионного ключа для KDC и содержит:</p>
     <ul>
      <li>Сессионный ключ для общения с сервисом</li>
      <li>Метка времени</li>
      <li>Срок жизни TGS билета</li>
      <li>Принципал сервиса</li>
     </ul>
     <p>Второе сообщение (TGS билет) зашифровано с использованием секрета сервиса и включает в себя те же самые данные, что и первое сообщение, а также принципал клиента.</p>
     <p>Клиент, приняв ответ, может расшифровать только первое сообщение. Таким образом он получает сессионный ключ для дальнейшего общения с сервисом. TGS билет сохраняется у клиента в зашифрованном виде.</p>
     <h3 id="krb_ap_req">KRB_AP_REQ</h3>
     <p><img src="./images/AP_REQ.png" alt="KRB_AP_REQ"></p>
     <p>Клиент отправляет сервису запрос на получение доступа, содержащий:</p>
     <ul>
      <li>Аутентификатор, состоящий из принципала клиента и метки времени, зашифрованных с использованием извлеченного ранее сессионного ключа для общения с сервисом.</li>
      <li>Сохраненный TGS билет</li>
      <li>Флаг взаимной аутентификации</li>
     </ul>
     <p>Приняв запрос, сервис прежде всего выполняет проверку полученных данных. Сначала с использованием своего секрета сервис расшифровывает TGS (1) и по метке времени со сроком действия убеждается, что TGS не протух (2). Далее сервис извлекает сессионный ключ.</p>
     <p>TGS билет не может быть изменен кем-либо кроме того, кто знает секрет сервиса, а это KDC и сам сервис. Сервис доверяет KDC, таким образом извлеченным из TGS билета данным сервис также может доверять.</p>
     <p>Аналогично KRB_TGS_REQ расшифровывается аутентификатор и выполняются другие проверки. Обратите внимание, что сервис удостоверяется в подлинности клиента, не обращаясь к KDC.</p>
     <h3 id="krb_ap_rep">KRB_AP_REP</h3>
     <p><img src="./images/AP_REP.png" alt="KRB_AP_REP"></p>
     <p>Опционально, в случае если активен флаг взаимной аутентификации, сервис также подтверждает перед клиентом свою подлинность, отправив ответ с меткой времени, зашифрованной с использованием сессионного ключа.</p>
     <h2 id="kerberos-в-active-directory">Kerberos в Active Directory</h2>
     <p><em>«Чтобы донести идею её надо рассказать три раза, но разными словами»</em> <em>(с)</em></p>
     <p>Рассмотрим реализацию Kerberos в Active Directory. Уточним терминологию, теперь:</p>
     <p><strong>Область действия</strong> – домен.</p>
     <p><strong>Центр распределения ключей</strong> – контроллер домена.</p>
     <p><strong>Сервер аутентификации</strong> и <strong>сервер выдачи разрешений</strong> – оба объединены в рамках одного компонента, функционирующего на контроллере домена.</p>
     <p><strong>База данных Kerberos</strong> – в Active Directory информация о секретах пользователей хранится на контроллерах домена в файле ntds.dit.</p>
     <p><strong>krbtgt</strong> – название учетной записи, по умолчанию создаваемой вместе с доменом и обладающей секретом контроллера домена.</p>
     <p>В итоге с учетом переименований получается следующая структура:</p>
     <p><img src="./images/ad_realm_high-AP.png" alt="ad_realm"></p>
     <p>В целом в Active Directory Kerberos работает согласно RFC, но есть ряд особенностей. Рассмотрим указанные особенности на следующем примере.</p>
     <h3 id="доменная-аутентификация-пользователя-к-рабочей-станции-в-active-directory">Доменная аутентификация пользователя к рабочей станции в Active Directory</h3>
     <p>Изначально на рабочей станции активно следующее диалоговое окно:</p>
     <p><img src="./images/screen.png" alt="logon_screen"></p>
     <p>Пользователь вводит свои учетные данные (название домена, имя учетной записи, пароль) и жмет «OK». Далее компонент, ответственный за отображение диалогового окна, передает запрос на аутентификацию пользователя с использованием введенных данных в локальный центр безопасности (<em>Local Security Authority, LSA</em>). Центр содержит различные динамические библиотеки, предоставляющие функции для процедур аутентификации, смены паролей, а также выдачи токенов. Указанные библиотеки вызываются и работают в контексте процесса lsass.exe (<em>Local Security Authority Subsystem Service</em>).</p>
     <p>В зависимости от запроса для его обработки согласовывается соответствующая библиотека. Примеры библиотек и протоколов:</p>
     <ul>
      <li>msv1_0.dll (NTLM)</li>
      <li>kerberos.dll (Kerberos)</li>
      <li>SChannel.dll (TLS/SSL)</li>
      <li>WDigest.dll (digest аутентификация)</li>
     </ul>
     <p>По умолчанию для обработки запросов на проверку подлинности пользователя при входе в домен выбирается библиотека kerberos.dll, реализующая одноименный протокол.</p>
     <p>Следует понимать, что пользователь никогда напрямую не взаимодействует с системой. Система олицетворяет пользователя и получает доступ к необходимым ресурсам с использованием прав доступа, которыми указанный пользователь обладает. Таким образом систему в ходе аутентификации можно рассматривать как сервис.</p>
     <p>В итоге имеем следующую картину:</p>
     <p><img src="./images/KRB_Worstation_Start.png" alt="KRB_Worstation_Start"></p>
     <p>Секрет системы (ключ) присваивается рабочей станции при ее добавлении в домен. Важно отметить, что введенный пользователем пароль не хранится в памяти рабочей станции. Ключ пользователя формируется при помощи ранее рассмотренной хэш-функции string2key.</p>
     <p>Далее процесс, обеспечивающий аутентификацию пользователя, обращается к контроллеру домена с использованием сформированного ключа. Здесь проявляется одна из особенностей реализации Kerberos в Active Directory – предварительная аутентификация по умолчанию включена.</p>
     <h3 id="krb_as_req-с-предварительной-аутентификацией">KRB_AS_REQ с предварительной аутентификацией</h3>
     <p><img src="./images/KRB_AS_REP_AD.png" alt="KRB_AS_REP_AD"></p>
     <p>В этом случае клиент отправляет серверу аутентификации запрос, содержащий:</p>
     <ul>
      <li>Принципал клиента</li>
      <li>Метку времени, зашифрованную с использованием секрета клиента</li>
     </ul>
     <p>Получив запрос, контроллер домена с помощью секрета клиента расшифровывает метку времени и сравнивает её с текущим значением. Если переданное время расходится с текущим меньше чем на пять минут, то значит предварительная аутентификация клиента успешно пройдена. В противном случае контроллер отправляет сообщение об ошибке.</p>
     <h3 id="krb_as_rep-ad">KRB_AS_REP (AD)</h3>
     <p>В случае успешного прохождения предварительной аутентификации контроллер домена отправляет рабочей станции ответ, аналогичный рассмотренному в разделе про RFC.</p>
     <p><img src="./images/KRB_ASREP_PAC.png" alt="KRB_ASREP_PAC"></p>
     <p>В ответе появилась еще одна особенность, а именно новое поле «PAC» в содержимом TGT.</p>
     <p>PAC (<em>Privilege Attribute Certificate</em>) это данные, предназначенные для авторизации пользователя. Ранее уже отмечалось, что кроме аутентификации Kerberos может использоваться при авторизации, но не пояснялось как. Поле PAC изначально было предусмотрено в RFC без конкретного описания содержимого. Какая информация передается в PAC и как она обрабатывается зависит от конкретной реализации Kerberos.</p>
     <p>В Active Directory PAC среди прочего содержит следующую информацию:</p>
     <ul>
      <li>Идентификатор безопасности (SID) учетной записи пользователя</li>
      <li>Идентификаторы групп, в которых состоит пользователь</li>
     </ul>
     <p>Указанная информация дважды подписывается. Одна подпись принадлежит krbtgt, а вторая сервису, к которому обращался клиент (в случае KRB_AS_REP тоже krbtgt).</p>
     <h3 id="krb_tgs_req-ad">KRB_TGS_REQ (AD)</h3>
     <p>Запрос производится аналогично рассмотренному ранее в RFC.</p>
     <p><img src="./images/AUTH_TGS_REQ.png" alt="AUTH_TGS_REQ"></p>
     <h3 id="krb_tgs_rep-ad">KRB_TGS_REP (AD)</h3>
     <p>PAC из TGT, полученный в предыдущем сообщении, помещается в TGS билет. В этот раз PAC подписывается не только с использованием секрета krbtgt, но и секрета системы.</p>
     <p><img src="./images/AUTH_TGS_REP.png" alt="AUTH_TGS_REP"></p>
     <h3 id="logon">LOGON</h3>
     <p>С использованием сессионного ключа LSA извлекает подписанный PAC из TGS билета. LSA проверяет подпись PAC при помощи секрета системы и далее с учетом добытых из PAC доменных групп безопасности формирует процесс Winlogon c соответствующим токеном доступа клиента.</p>
     <p><img src="./images/AUTH_Logon.png" alt="AUTH_Logon"></p>
     <p>Опционально система может запросить контроллер домена выполнить дополнительную проверку подписи с PAC с помощью секрета krbtgt.</p>
     <h2 id="итог">Итог</h2>
     <p>Думаю, для поверхностного знакомства с Kerberos достаточно. Несмотря на то, что многие моменты остались за скобками, представленного материала в целом хватает для понимания атак на протокол Kerberos, которые рассмотрим в следующей части.</p>
     <h3 id="ссылки-на-используемые-источники">Ссылки на используемые источники</h3>
     <ul>
      <li><a href="https://www.kerberos.org/software/tutorial.html">Kerberos Protocol Tutorial</a> (Fulvio Ricciardi)</li>
      <li><a href="https://medium.com/@robert.broeckelmann/kerberos-and-windows-security-series-59282e0f9465">Kerberos and Windows Security Series</a> (Robert Broeckelmann)</li>
      <li>Статья с <a href="https://pro-ldap.ru/tr/zytrax/tech/kerberos.html">pro-ldap.ru</a></li>
      <li><a href="https://en.hackndo.com/kerberos">Блог</a> Pixis</li>
      <li>Фундаментальная <a href="https://www.tarlogic.com/blog/how-kerberos-works/">статья</a> c tarlogic.com (Eloy Pérez)</li>
      <li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815(v=ws.10)?redirectedfrom=MSDN">Документация Microsoft</a></li>
      <li><a href="https://sheerazali.com/how-to-kerberos-its-components-and-function/">How to Kerberos? its components and function</a> (Sheeraz Ali)</li>
      <li><a href="https://blog.redforce.io/windows-authentication-attacks-part-2-kerberos/">Windows authentication attacks part 2 – kerberos</a> (Ahmed Sultan)</li>
     </ul>
     <p>Картинка для обложки взята <a href="https://pikabu.ru/story/malyish_tserber_5496474">отсюда</a>.</p>
    </div>
   </article>
  </main><a href="#top"></a>
 </body>
</html>